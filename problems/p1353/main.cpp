#include <cstdio>
#include <cmath>
#include <vector>
#include <climits>
#include <string>
#include <algorithm>
#include <unordered_map>
#include <queue>

using namespace std;

void print_table(vector<vector<int>>& table) {
    for (int i = 0; i < table.size(); i++) {
        for (int j = 0; j < table[i].size(); j++) {
            printf("%2d ", table[i][j]);
        }
        printf("\n");
    }
}

inline void hash_combine(std::size_t& seed) { }
template <typename T, typename... Rest>
inline void hash_combine(std::size_t& seed, const T& v, Rest... rest) {
    std::hash<T> hasher;
    seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
    hash_combine(seed, rest...);
}

struct Key {
    int index;
    int k;
    Key() {};
    Key(int index, int k) : index(index), k(k){}

    std::size_t operator()(const Key &v) const
    {
        std::size_t h = 0;
        hash_combine(h, v.index, v.k);
        return h;
    }

    bool operator()(const Key &a, const Key &b) const
    {
        return a.index == b.index && a.k == b.k;
    }
};

using Map = unordered_map<Key, int, Key, Key>;

class Solution {
public:
    int bisect_right(vector<vector<int>>& events, int target) {
        int left = 0;
        int right = events.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (events[mid][0] <= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }

    int top_down(vector<vector<int>>& events, int index, int k, Map& memo) {
        Key key(index, k);

        if (k == 0 || index >= events.size()) {
            return 0;
        }
        if (memo.find(key) != memo.end()) {
            return memo[key];
        }

        int next_index = bisect_right(events, events[index][1]);
        int a = top_down(events, next_index, k-1, memo);
        int b = top_down(events, index + 1, k, memo);
        int best = max(a + events[index][2], b);
        memo[key] = best;
        return best;
    }

    int bottom_up(vector<vector<int>>& events, int k) {
        vector<vector<int>> dp(k+1, vector<int>(events.size()+1, 0));

        for (int ki = 1; ki <= k; ki++) {            
            for (int ei = events.size()-1; ei >= 0; ei--) {

                int next_event = bisect_right(events, events[ei][1]);
                int a = dp[ki-1][next_event];      // Take the event
                int b = dp[ki][ei + 1];            // do not take the event
                dp[ki][ei] = max(a + events[ei][2], b);
            }
        }

        return dp[k][0];
    }

    int maxValue(vector<vector<int>>& events, int k) {
        sort(events.begin(), events.end());
        return bottom_up(events, k);
        // Map memo;
        // return top_down(events, 0, k, memo);
    }
};

int main() {
    Solution s;

    vector<tuple<vector<vector<int>>, int>> cases = {
        {{{1,2,4},{3,4,3},{2,3,1}}, 2},           // 7
        {{{1,2,4},{3,4,3},{2,3,10}}, 2},          // 10
        {{{1,1,1},{2,2,2},{3,3,3},{4,4,4}}, 3},   // 9

        {
            {{609160999,612582699,443422},{947166815,953380719,500128},{509665293,518745581,149858},{625034765,625478636,483866},{781784820,782291828,143346},{174077331,177609753,180156},{800863484,802150672,320499},{379280423,386305516,744771},{972166957,973110948,79556},{692103213,692598640,469358},{108578958,116774463,345270},{256592151,260217350,664230},{268985479,286614436,166394},{42376830,44672481,667237},{530474061,531435025,452033},{180856546,188537226,395742},{338388551,342982219,401949},{507351469,507913727,549999},{154302831,156765309,406069},{290607284,300207459,948892},{888281045,892881727,248408},{446315936,447061616,104646},{815494172,825477446,398940},{756050332,776209136,521588},{779316632,779549080,963107},{869704183,872729766,5720},{462503443,469555485,895241},{693441085,694978338,185090},{841934770,868854132,55140},{989043039,989602115,353190},{900176469,902174676,79381},{474974825,479638162,503580},{304661378,309185429,599881},{684127403,687829874,472919},{351618428,354094470,598001},{973498017,974205681,946253},{210602172,217465066,704733},{420357195,433111080,52113},{563437917,575174843,702873},{804172347,805364877,714162},{458919059,462050133,35108},{9000788,13150406,652181},{35828449,39094628,145541},{959143837,968532446,617744},{631923914,640240749,156275},{953553442,954876995,989019},{875555671,887619098,895006},{699569058,703133773,404319},{54860536,59914250,76485},{922504737,924918759,33579},{260430887,260483505,177717},{227082211,227559556,413159},{335782302,336897527,679183},{697081841,697880997,396999},{368668959,371316049,731831},{560095497,560975547,711041},{681339475,684097936,419920},{309355796,314934275,127300},{262996731,267567670,375651},{195847429,195906540,855488},{656383532,680387682,487017},{598421277,607100426,384007},{170054420,173421313,337141},{236881563,238498845,879035},{244664075,250331115,280780},{825480669,829419535,98586},{984255323,986838580,915106},{523252252,523269720,896046},{577361186,579854206,687101},{74202559,74304669,654998},{493376690,501763167,566016},{66486085,68558701,116854},{753219176,755396614,413036},{403217227,412032555,364961},{730136072,739387262,15180},{538674042,546547794,283571},{990161375,994240716,486296},{287295040,290465999,253402},{127475277,131381124,459808},{69961343,70828607,437234},{448033366,450427314,576909},{581073127,583845957,819991},{649107027,653839062,114275},{72670974,72791272,208621},{434126470,435830132,647362},{795717304,799240429,774654},{90483158,96047309,785088},{588970519,595272687,241911},{80939799,81840097,900259},{333231653,334320961,415819},{251486136,251901288,854597},{140956566,152440434,418734},{100247381,105571047,758200},{695750330,696415680,461183},{918078263,918890629,26172},{906947242,912435095,769132},{750796382,751146332,766352},{932653715,943945433,151639},{787417692,790849298,545930},{479778644,481390273,245309}},
            50
        }  // 34368847

    };
    for (auto c : cases) {
        printf("%d\n", s.maxValue(std::get<0>(c), std::get<1>(c)));
    }
    return 0;
}